import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;

public class BusinessMasterListInterceptor  {

	@Service("DateService")
	def dateSvc;

	@After(pattern="QueryService.getNodeList", eval="#{args[0]._schemaname == 'vw_business_account' }")
	public def getNodes(def evt) {
		def nodes = evt.result;
		nodes  <<  [name:'active', title:'Active (w/o Permit)'];
		nodes  <<   [name:'activep', title:'Active w/ Permit'];
		nodes  <<   [name:'retired', title:'Retired'];
		nodes  <<   [name:'processing', title:'Processing'];
		//nodes  <<   [name:'cancelled', title:'Cancelled'];
		nodes  <<   [name:'renewal', title:'For Renewal'];
		nodes  <<   [name:'delinquent', title:'Delinquent'];
	}	

	@Before(pattern="QueryService.getList", eval="#{args[0]._schemaname == 'vw_business_account' }")
	public void beforeList(evt) {
		def o = evt.args[0];
		if( !o.node?.name ) return;

		int activeyear = dateSvc.getServerYear();
		def str = null;
		def m = [:];
		switch(o.node.name) {
			case 'search':
				if( !o.searchtext || o.searchtext == '%' ) o.searchtext = "?";
				break;
				
			//--------------- processing--------------------	
			case 'active':
				m.activeyear = activeyear;
				str = " year= :activeyear AND taskstate = 'end' AND permitid IS NULL AND closureid IS NULL";
				break;

			case 'activep':	
				m.activeyear = activeyear;
				str = " year= :activeyear AND NOT(permitid IS NULL) AND closureid IS NULL";
				break;

			case 'retired':
				str = " NOT( closureid IS NULL ) ";
				break;

			case 'processing':
				str = " closureid IS NULL AND NOT(taskstate = 'end') ";
				break;

			case 'renewal':
				m.curryear = activeyear;
				m.prevyear = activeyear - 1;
				str = " closureid IS NULL AND ((year = :prevyear) OR (year=:curryear AND renewaldate <= NOW()))";	
				break;	

			case 'delinquent':
				m.activeyear = activeyear - 1;
				str = " year < :activeyear AND closureid IS NULL ";	
				break;	

			default:
				break;
		}

		if( o.where ) {
			o.where[0] = str + " AND " + o.where[0];	
			o.where[1].putAll( m );
		}
		else {
			o.where = [str, m];
		} 

	}

	

}